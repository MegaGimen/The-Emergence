# 目前正在修的bug1

## 实验1

实验证明，**只要你bootstrap了一个被内网穿透的节点**，那么不管它是服务器还是客户端，连接者都无法再接收信息

但是，如果你bootstrap了一个没有被内网穿透的节点，也就是内网节点，那么你即使内网穿透了，也可以继续接收信息

## 理论1
所谓“正常通信”，不过是收信方是否有能力接收信息，所以信件发出方不重要，而重要的是接收方是否有能力接收

如果让GPU服务器为C（port=8469），我Windows电脑为B（port=8469），Linux为A（port=8490），内网穿透服务器为O

以下通路不通：
$$
M \rightarrow B \rightarrow O\rightarrow C(忽略)\\
M \rightarrow B \rightarrow C(忽略)\\
M \rightarrow O \rightarrow B \rightarrow C\\
M \rightarrow A \rightarrow O \rightarrow  B \rightarrow O \\\rightarrow C(忽略)\\
$$
以下是通的：
$$
M \rightarrow C(忽略)\\
M \rightarrow O \rightarrow C\\
M \rightarrow O \rightarrow  B \rightarrow O \rightarrow C \textbf{但是，当B节点停止运行并再次启动时，此路却不通了，而如果C节点重启，然后B节点再启动，此路又通了}\\
M \rightarrow O\rightarrow A\rightarrow O \rightarrow  B \rightarrow O \rightarrow C \textbf{但是，当B节点停止运行并再次启动时，此路却不通了，而如果从右往左重新启动，就又通了}\\
$$

## 结论

在本论文中，我们讨论了为什么这一堆傻逼节点不能连接，我们发现，内网穿透不应该背锅的，而真正应当背锅的，是**启动顺序**，必须从右向左**线性启动**才可以，而众所周知，在哈耶克的眼中，网络是非线性的结构，所以线性启动充满了中心化的恶臭味

## 未来期望

我们希望可以制造一个更具有鲁棒性的，更可以灵活处理节点进出的情况（包括KeyboardInterrupt，用户退出，电脑关机，电脑受到病毒入侵，电脑受到肘击，电脑所在位置被恐怖分子使用$AK47$进行扫射而冒烟，电脑使用者启动原神而被制裁等），这需要我们对kademlia底层逻辑有一个更深的了解

## 调试

A节点：48890

B节点的IP固定为43678

C节点的IP为59262

## 理论2

我初步认为，是节点的rpc_ping因为一些奇怪的原因没有被调用，所以才导致ping失败的，但是这个理论仍然存疑，因为如果对这些节点发送正常的UDP请求的话，节点也没有进行响应，所以一定有什么东西，阻碍了节点被**以任何形式的访问**

## 理论3

我认为，也有可能是节点在处理UDP协议时有一个逻辑（也就是输出那个ignoring的逻辑），而接收ping函数的远程调用时也有一个逻辑（rpc_ping），那么这两个函数有可能分别失效了，所以导致了这种情况

## 实验2

假设现在有两个节点，B和C，C开的引导节点，B和C都是静态IP，那么经过测试，我们发现：

下一步的计划是查看服务器的路由表，我到想看看，那里到底存下来了什么。

同时，我也怀疑有可能在服务器残存的路由表（尤其是服务器踢人ping用的节点）干扰了网络正常运行

我终于找到bug的出处了！找了三天啊！还真和内网穿透有关，由于引导节点在接受一个新节点的请求时，会把一个因ping和find_node源节点存入自己的路由表里，而且由于内网穿透的原因，这个源节点的port**可能是随机的**，也就是说，同一个非引导节点进行ping和find_node所使用的两个端口是不同的，这就导致了引导节点的路由表存入了一些已经不适用的port，进而导致卡崩（而且存入过多无关节点也会导致节点启动降速）
这个和内网穿透的NAT有关，正在联系西部数码

# 目前已经改完的：

1. 完成了ping的ip地址额外信息

# 已发现且需要完成的

1. find_val

2. find_node

$\dots$

BUG已解决！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

# 目前正在修的bug2

如果节点查询失败（也就是输入了不存在的人物关系），那么非引导节点就会把引导节点踢出路由表，会显示"no response from XXX"的错误，但这个bug和bug1相比还是没那么严重

不！！！非常严重！！！

# 目前正在修的bug3

这其实算是从bug1派生出来的一个bug，就是应该修改中心服务器节点的ping规则

# 目前正在修的bug4

当按一个按钮多次时，我不知道会发生什么，这可能会带来代码健壮性的问题

# *目前正在修的bug5

这是一个极其严重的问题，它有可能是很多bug的基bug

假如B节点是引导节点的，A节点不是，那么如果B节点路由表中存储的一个节点ip不能用了（比如退出了网络），假设它是C，**而且C是原来的A节点的id，即A节点中途退出了，换了一个id，值得注意的是，由于我已经通过显式增加额外信息来使得ip地址固定了，但是id会变，，这将会导致不同的id对应了相同的ip**，那么它不会显式移除它（显式删除需要向节点发送请求，比如findnode才可以），那么假如A节点要去连接B节点这个引导节点，那么会得到C节点的地址（kademlia的简单的发现机制），等到A节点去向C节点发送信息时，会得知它**无法访问**，那么它就会把它从自己的路由表中移除，这一切看似没有什么问题，但是，如果A节点退出后再次向B节点请求路由表时，他就会得到“曾经的它自己”，而由于**唯一的id不同**，所以A节点并不会把它排除掉

所谓的强健性，其实是**灵活处理节点进出**，也就是说，